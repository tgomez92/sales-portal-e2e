# sales-portal-e2e

About: This project has been developed to automate the Sales Portal Process. It uses Cucumber, WebdriverIO, Allure Reporter & Mocha.  
  
#  Index
  1. General Structure 
  2. Wdio config
  3. Feature files 
  4. Step definitions 
  5. Page Objects 
  6. Utils 
  7. Context (world)
  8. Reporter 
  
  # 1. General Structure 💾
  
  The project is structured as follows: 
  - 📊 allure-report / allure-results : both folders contain files related to allure-reporter. They are auto-generated by the reporter. 
  - 🔋 features: main folder containing: feature files, step definition files and page object files 
  - 📸 reports: folder in which screenshots are saved (when a test fails)
  - 🛠 utils: folder containing helpers, enums and literals that are used by the different tests
  - 🫀 wdio.config.js: main configuration file containing all details for test excecutions
  - 🧠 world.js: general context for information that needs to be shared among steps. 
  
  # 2. Wdio Config 🧠
  
  This file contains all the configuration needed to run the tests. In order to understand it better please refer to https://webdriver.io/docs/configurationfile. The main sections to be configured in this documents are: 
  
  - Capabilities array: it contains browser objects with the desired capabilities for each one. Right now the project supports Chrome and Firefox (to be expanded to include others). If you need to modify something browser-related this is the place to do it. 
  - baseUrl: this is the url used to open the browser, ⚠️this value may be change but it must be returned to its default value before pushing code⚠️
  - Timeout object: this values are used among pages to set timeouts for dynamic waits, unless needed for some testing purpose, this object must not be modified. 
  - Reporters array: contains configuration for each desired reported (right now only Allure is implemented)
  - cucumberOpts: object in which all cucumber configurations are stored.
  - Hooks: we use hooks to define actions that we need to execute at a certain moment.
  
  # 3. Feature Files 📑
  
  Each .feature file describes a set of scenarios that are englobed under the same functionality. They are written in Gherkin (https://cucumber.io/docs/gherkin/) and follow a certain set of DOs and DON'Ts: 
  
  - ✅ Use tags for the different Scenarios (at least one scenario per feature must have @smoke, all scenarios must have @web @salesPortal @FeatureNameXXX)
  - ✅ Only use one When/Then sentence per scenario
  - ✅ Reuse steps from other features as much as possible 
  
  - ❌ Write steps that are similar to others already written. Example: imagine there's a steps implemented that reads: "The user is taken to Your Info screen", and I want implement this other step: "The user is taken to Coverages screen". Instead, I could change it into "The user is taken to <page> screen" and parametrize the sentence. 
  - ❌ Wrtite scenarios that are testing the same exact flow but expecting different results, instead, try to send parameters via table to differentiate one scenario from the other 
  
  # 4. Step Definitions 💬
  
  These files are in charge of translating the .feature files into JavaScript code. This is the place from which we call our Page Objects and their methods to simulate the different user actions. 
  
  Each step definition file corresponds to only one Page Object, all the steps that take place in a given page must be under the same step definition file. That's why the files are named as follow: [pageName].steps.js (example: coveragePage.steps.js).
  
  In case a step needs to call several Page Object classes, we can implement it in common.steps.js. 
  
  DOs / DON'Ts
  
  - ✅ Keep the relation 1:1 between page object and step file 
  - ✅ Implement generic steps in common file 
  - ✅ Import information such as: user, address, etc (if it's not passed as a parameter) 
  - ✅ Import other pages only for navigation purposes 
  
  - ❌ Implement pages actions in step definitions 
  - ❌ Duplicate step definitions that do basically the same, try to parametrize them instead. 
  
  # 5. Page Objects 🖥
  
  Page Object files are JavaScript classes that represent a page in our application (example: Home Page, Rewards Page, Coverage Page, etc). Each page inherits from a Page.js class that contains shared methods as well as the constructor. Each Page Object class has a certain amount of elements (which represent the different elements on a page) and methods (which represent user actons). 
  
  Example: The element "name input" and the method "fillNameinput" 
  
  SELECTORS: The elements are obtained using the selectors provided by WebdriverIO $$(condition) or $(condition). The first one returns all web elements that match that condition whilst the latter only returns the first result. That condition is a CSS selector that represent the element we are looking for. 
  
  Example: 
  - I want to locate the firstName input, that has an Id = "firstName" => $('#firstName') [Single element selector]
  - I want to locate the different li inside an ul with a className = "rated-rewards" => $$('.rated-rewards li') [Multiple elements selector]
  
  There are some elements that are treated as "components" (spinner, quotebox) because they are not a page but shared among different pages. Most of them are imported in the Page.js class and used from the extended classes. 
  
  All pages must implement the getPageUrl() method and goToNextPage() method, the first method return the url (used to validate we are on the correct screen), the second method implements the logic that allows the user to continue on the journey. 
  
  DO / DON'T 
  
  - ✅ Define page elements using strong selectors (preferably using ids/classes)
  - ✅ Use CSS to locate page elements 
  - ✅ Name the methods in a way that they result descriptive (feel free to add a comment when needed) 
  - ✅ Implement dynamic waits 
  - ✅ Use the custom commands defined in wdio.conf.js
  
  - ❌ Use elements from other pageObject classes in a method 
  - ❌ Use selectors that depend on hierarchy or texts values 
  - ❌ Implement static waits (browser.pause())
  - ❌ Implement validation in Page Object methods 
  
  # 6. Utils 🧰
  
  Utils folder contains files that are used to assert, transform, provide data to the tests. This is its content: 
  
  - assertions.js: contains assertions that use Chai.js, used to verify conditions in Then steps. 
  - enums.js: contains enums commonly used in classes / steps 
  - helpers.js: functions that aim to facilitate some operations during text execution 
  - literals.js: contains all text data to run the tests (addresses, users, etc) 
 
 Notes:
  - ✅ Define enums to use in switch cases (Instead of "case 'pet reward':" use "case rewards.nonRatedRewards.PET_RWD")
  - ✅ Define all data/text in literals/js
  
  # 7. Context (world.js)🌎
  
  The aim of world.js is to share information between steps during a test excecution. Imagine you are testing a premium change, you need to know what was the premium before the change took place in order to compare it to the new one. This is when world.js comes in handy, you just save that value and use it afterwards. 
  
  - ✔️ Use world.js to save any kind of information: numbers, objects, arrays, strings. 
  - ✔️ Useful to determine milestones in multi-step pages (Example: Coverage Page) 
